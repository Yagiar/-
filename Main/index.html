<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="./css/MainStyle.css" rel="stylesheet" type="text/css"/>
    <link href="./css/popup.css" rel="stylesheet" type="text/css"/>
    <script src="./js/jquery-3.6.1.min.js"></script>
    <script src="./js/node.js"></script>
    <title>Main</title>
</head>
<body>
<main class="main">
<div class="header-wrap">
        <header class="header">
            <div class="Logo">           
                <div class="divImage" style="background-image:url(./resources/Logo.jpg);">
                </div>
                <div class="divText" onclick="show_popup('.order_popup');">
                Приветствую вас на моем макете!
                </div>
            </div>
            <div class="Name">
                 <p>Макет Дмитрия Терешкина</p>
            </div>
            
        </header>
</div>
<span class="menuButton" onclick="MenuToggle();">Меню</span>
<nav class="navigation">
    <div class="puncts"><a href="./index.html">Главная</a></div>
    <div class="puncts"><a href="./Search.html">Поиск</a></div>
    <div class="puncts"><a href="./ObrSv.html">Обратная связь</a></div>
    <div class="puncts"><a href="./ListLiterature.html">Список литературы</a></div>
    <div class="puncts"><a href="./Contacts.html"> Контакты</a></div>
</nav>
<div class="middle">
    <div class="MyImageBlock">
        <div class="MyImage" style="background-image:url(./resources/Logo.jpg)"></div>
    </div>
<p>Динамическое программирование по подмножествам (по маскам)
Задача о коммивояжере представляет собой поиск кратчайшего гамильтонова цикла в графе. Зафиксируем начальную вершину ss и будем искать гамильтонов цикл наименьшей стоимости — путь от ss до ss, проходящий по всем вершинам (кроме первоначальной) один раз. Т.к. искомый цикл проходит через каждую вершину, то выбор ss не имеет значения. Поэтому будем считать s=0s=0.
Подмножества вершин будем кодировать битовыми векторами, обозначим maskimaski значение ii-ого бита в векторе maskmask.
Обозначим d[i][mask]d[i][mask] как наименьшую стоимость пути из вершины ii в вершину 00, проходящую (не считая вершины ii) единожды по всем тем и только тем вершинам jj, для которых maskj=1maskj=1 (т.е. d[i][mask]d[i][mask] уже найденный оптимальный путь от ii-ой вершины до 00-ой, проходящий через те вершины, где maskj=1maskj=1. Если maskj=0maskj=0,то эти вершины еще не посещены).
Алгоритм поиска цикла будет выглядеть следующим образом:
Начальное состояние — когда находимся в 00-й вершине, ни одна вершина не посещена, а пройденный путь равен 00 (т.е. i=0i=0 и mask=0mask=0).
Для остальных состояний (i≠0i≠0 или mask≠0mask≠0) перебираем все возможные переходы в ii-ую вершину из любой посещенной ранее и выбираем минимальный результат.
Если возможные переходы отсутствуют, решения для данной подзадачи не существует (обозначим ответ для такой подзадачи как ∞∞).
Стоимостью минимального гамильтонова цикла в исходном графе будет значение d[0][2n−1]d[0][2n−1] — стоимость пути из 00-й вершины в 00-ю, при необходимости посетить все вершины. Данное решение требует O(2n×n)O(2n×n) памяти и O(2n×n2)O(2n×n2) времени.
Для того, чтобы восстановить сам путь, воспользуемся соотношением d[i][mask]=w(i,j)+d[j][mask−2j]d[i][mask]=w(i,j)+d[j][mask−2j], которое выполняется для всех ребер, входящих в минимальный цикл . Начнем с состояния i=0i=0, mask=2n−1mask=2n−1, найдем вершину jj, для которой выполняется указанное соотношение, добавим jj в ответ, пересчитаем текущее состояние как i=ji=j, mask=mask−2jmask=mask−2j. Процесс заканчивается в состоянии i=0i=0, mask=0mask=0.Для того, чтобы восстановить сам путь, воспользуемся соотношением d[i][mask]=w(i,j)+d[j][mask−2j]d[i][mask]=w(i,j)+d[j][mask−2j], которое выполняется для всех ребер, входящих в минимальный цикл . Начнем с состояния i=0i=0, mask=2n−1mask=2n−1, найдем вершину jj, для которой выполняется указанное соотношение, добавим jj в ответ, пересчитаем текущее состояние как i=ji=j, mask=mask−2jmask=mask−2j. Процесс заканчивается в состоянии i=0i=0, mask=0mask=0.
Для того, чтобы восстановить сам путь, воспользуемся соотношением d[i][mask]=w(i,j)+d[j][mask−2j]d[i][mask]=w(i,j)+d[j][mask−2j], которое выполняется для всех ребер, входящих в минимальный цикл . Начнем с состояния i=0i=0, mask=2n−1mask=2n−1, найдем вершину jj, для которой выполняется указанное соотношение, добавим jj в ответ, пересчитаем текущее состояние как i=ji=j, mask=mask−2jmask=mask−2j. Процесс заканчивается в состоянии i=0i=0, mask=0mask=0.
Для того, чтобы восстановить сам путь, воспользуемся соотношением d[i][mask]=w(i,j)+d[j][mask−2j]d[i][mask]=w(i,j)+d[j][mask−2j], которое выполняется для всех ребер, входящих в минимальный цикл . Начнем с состояния i=0i=0, mask=2n−1mask=2n−1, найдем вершину jj, для которой выполняется указанное соотношение, добавим jj в ответ, пересчитаем текущее состояние как i=ji=j, mask=mask−2jmask=mask−2j. Процесс заканчивается в состоянии i=0i=0, mask=0mask=0.
Для того, чтобы восстановить сам путь, воспользуемся соотношением d[i][mask]=w(i,j)+d[j][mask−2j]d[i][mask]=w(i,j)+d[j][mask−2j], которое выполняется для всех ребер, входящих в минимальный цикл . Начнем с состояния i=0i=0, mask=2n−1mask=2n−1, найдем вершину jj, для которой выполняется указанное соотношение, добавим jj в ответ, пересчитаем текущее состояние как i=ji=j, mask=mask−2jmask=mask−2j. Процесс заканчивается в состоянии i=0i=0, mask=0mask=0.
Для того, чтобы восстановить сам путь, воспользуемся соотношением d[i][mask]=w(i,j)+d[j][mask−2j]d[i][mask]=w(i,j)+d[j][mask−2j], которое выполняется для всех ребер, входящих в минимальный цикл . Начнем с состояния i=0i=0, mask=2n−1mask=2n−1, найдем вершину jj, для которой выполняется указанное соотношение, добавим jj в ответ, пересчитаем текущее состояние как i=ji=j, mask=mask−2jmask=mask−2j. Процесс заканчивается в состоянии i=0i=0, mask=0mask=0.
Для того, чтобы восстановить сам путь, воспользуемся соотношением d[i][mask]=w(i,j)+d[j][mask−2j]d[i][mask]=w(i,j)+d[j][mask−2j], которое выполняется для всех ребер, входящих в минимальный цикл . Начнем с состояния i=0i=0, mask=2n−1mask=2n−1, найдем вершину jj, для которой выполняется указанное соотношение, добавим jj в ответ, пересчитаем текущее состояние как i=ji=j, mask=mask−2jmask=mask−2j. Процесс заканчивается в состоянии i=0i=0, mask=0mask=0.
Для того, чтобы восстановить сам путь, воспользуемся соотношением d[i][mask]=w(i,j)+d[j][mask−2j]d[i][mask]=w(i,j)+d[j][mask−2j], которое выполняется для всех ребер, входящих в минимальный цикл . Начнем с состояния i=0i=0, mask=2n−1mask=2n−1, найдем вершину jj, для которой выполняется указанное соотношение, добавим jj в ответ, пересчитаем текущее состояние как i=ji=j, mask=mask−2jmask=mask−2j. Процесс заканчивается в состоянии i=0i=0, mask=0mask=0.
</p>
<br>
<h1>Контент блок</h1>
<h2>Контент блок</h2>
<h3>Контент блок</h3>
<h4>Контент блок</h4>
<h5>Контент блок</h5>
<img src="./resources/Logo.jpg">
<p>
Динамическое программирование по подмножествам (по маскам)
Задача о коммивояжере представляет собой поиск кратчайшего гамильтонова цикла в графе. Зафиксируем начальную вершину ss и будем искать гамильтонов цикл наименьшей стоимости — путь от ss до ss, проходящий по всем вершинам (кроме первоначальной) один раз. Т.к. искомый цикл проходит через каждую вершину, то выбор ss не имеет значения. Поэтому будем считать s=0s=0.
Подмножества вершин будем кодировать битовыми векторами, обозначим maskimaski значение ii-ого бита в векторе maskmask.
Обозначим d[i][mask]d[i][mask] как наименьшую стоимость пути из вершины ii в вершину 00, проходящую (не считая вершины ii) единожды по всем тем и только тем вершинам jj, для которых maskj=1maskj=1 (т.е. d[i][mask]d[i][mask] уже найденный оптимальный путь от ii-ой вершины до 00-ой, проходящий через те вершины, где maskj=1maskj=1. Если maskj=0maskj=0,то эти вершины еще не посещены).
Алгоритм поиска цикла будет выглядеть следующим образом:
Начальное состояние — когда находимся в 00-й вершине, ни одна вершина не посещена, а пройденный путь равен 00 (т.е. i=0i=0 и mask=0mask=0).
Для остальных состояний (i≠0i≠0 или mask≠0mask≠0) перебираем все возможные переходы в ii-ую вершину из любой посещенной ранее и выбираем минимальный результат.
Если возможные переходы отсутствуют, решения для данной подзадачи не существует (обозначим ответ для такой подзадачи как ∞∞).
</p>
<a href="./index.html">&copy; 2022-My-First. All rights reseverd.</a>
<table class="table">
    <tr>
        <td colspan="3">1</td>
    </tr>
    <tr>
        <td>2</td>
        <td>3</td>
        <td>4</td>
    </tr>
    <tr>
        <td>5</td>
        <td>6</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
        <td>7</td>
    </tr>
</table>
</div>
</main>
<div class="footer-wrap">
    
    <span class="under_popup"></span>
    <footer class="footer">
<a href="./index.html">&copy; 2022-My-First. All rights reseverd.</a>
<div class="order_popup">
    <div class="popup_content">
         <div class="MyImage" style="background-image:url(./resources/ILOVEKZ.jpg)"></div>
    </div>
    <span class="close_popup" onclick="close_popup('.order_popup');">X</span>
</div>
</footer>
</div>
</body>
</html>